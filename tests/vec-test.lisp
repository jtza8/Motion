; Use of this source code is governed by a BSD-style
; license that can be found in the license.txt file
; in the root directory of this project.

(in-package :motion)

(defclass vec-test (test-case)
  ())

(defmacro assert-vec-equal (v1 v2)
  (let ((var-v1 (gensym))
        (var-v2 (gensym)))
    `(let ((,var-v1 ,v1)
           (,var-v2 ,v2))
       (assert-true (vec= ,var-v1 ,var-v2)
                    (format nil "~s != ~s"
                            ,var-v1 ,var-v2)))))

(def-test-method test-reader-macro ((test vec-test))
  (let ((a #v(1 2)))
    (assert-equal 1 (a a))
    (assert-equal 2 (b a))))

(def-test-method test-vec-ops ((test vec-test))
  (let ((vec (vec+ #v(1 2) #v(2 3) #v(4 5))))
    (assert-equal 7 (x vec))
    (assert-equal 10 (y vec))
  (let ((vec (vec+ #v(1 2) 3)))
    (assert-equal 4 (x vec))
    (assert-equal 5 (y vec)))
  (let ((vec (vec+ 5 #v(3 4))))
    (assert-equal 8 (x vec))
    (assert-equal 9 (y vec)))
  (assert-equal 12 (vec+ 4 8))
  (let ((vec (vec- 5 #v(3 4))))
    (assert-equal 2 (x vec))
    (assert-equal 1 (y vec)))
  (let ((vec (vec/ 12 #v(3 4))))
    (assert-equal 4 (x vec))
    (assert-equal 3 (y vec)))))

(def-test-method test-compare ((test vec-test))
  (let ((a #v(0 3))
        (b #v(4 6))
        (c #v(3 5)))
    (assert-true (vec= #v(1 2) #v(1 2) #v(1 2)))
    (assert-false (vec= #v(1 2) #v(1 2) #v(1 3)))
    (assert-true (vec< a b))
    (assert-false (vec< b a))
    (assert-false (vec< a c))
    (assert-true (vec<= a c))
    (assert-true (vec> b a))
    (assert-false (vec> a b))
    (assert-false (vec> c a))
    (assert-true (vec>= c a))
    (assert-true (axis= #v(1 1) #v(-1 -1)))
    (assert-false (axis= #v(1 1) #v(1 -1)))
    (assert-false (axis= #v(1 1) #v(-1 1)))))

(def-test-method test-overlap ((test vec-test))
  (assert-equal 1 (overlap #v(1 3) #v(2 5)))
  (assert-equal 1 (overlap #v(2 5) #v(1 3)))
  (assert-equal 0 (overlap #v(1 2) #v(2 3)))
  (assert-equal 0 (overlap #v(2 3) #v(1 2)))
  (assert-equal 2 (overlap #v(1 9) #v(1 3)))
  (assert-equal 2 (overlap #v(1 3) #v(1 9))))

(def-test-method test-intersect ((test vec-test))
  (assert-vec-equal #v(2 5) (intersect #v(-1 5) #v(2 6)))
  (assert-vec-equal #v(2 3) (intersect #v(-1 5) #v(2 3)))
  (assert-equal nil (intersect #v(-1 5) #v(8 10))))

(def-test-method test-min-max ((test vec-test))
  (let ((a #v(1 2)))
    (assert-true (vec= #v(-3 8) (min-max #v(-3 2) #v(1 8))))
    (assert-true (vec= #v(-3 8) (min-max a #v(2 4) #v(-3 8))))
    (assert-true (vec= #v(1 2) a))
    (assert-true (vec= #v(-3 6) (min-max 2 3 -2 -3 6 5)))))

(def-test-method test-dots ((test vec-test))
  (let ((a #v(1 2))
        (b #v(2 3)))
    (assert-equal 8 (dot a b))))

(def-test-method test-normalise ((test vec-test))
  (assert-true (vec= #v(0.6 0.8) (normalise #v(3 4))))
  (assert-true (vec= #v(0 0) (normalise #v(0 0)))))

(def-test-method test-vec-vector ((test vec-test))
  (assert-equal '(1 2) (coerce (vec-vector #v(1 2)) 'list))
  (assert-equal '(1 2) (coerce (vec-vector #v(1 2)) 'list)))